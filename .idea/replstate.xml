<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1429100613534">{:repl-history {:ide [], :local [&quot;(m :name)&quot; &quot;(def m {:name \&quot;alex\&quot; :surename \&quot;ananyev\&quot; :age 28 :birth #inst \&quot;24/12/1986\&quot;})&quot; &quot;(def m {:name \&quot;alex\&quot; :surename \&quot;ananyev\&quot; :age 28})&quot; &quot;(keys m)&quot; &quot;(vals m)&quot; &quot;(sort (vals m))&quot; &quot;(sorted-map m)&quot; &quot;#{ :age 12 :age 14 :name \&quot;vasya\&quot;}&quot; &quot;(set :age 12 :age 14 )&quot; &quot;(set {:age 12 :age 14})&quot; &quot;(seq \&quot;Hello\&quot;)&quot; &quot;(set (seq \&quot;Hello\&quot;))&quot; &quot;(str (set (seq \&quot;Hello\&quot;)))&quot; &quot;(ns msprandom.crypto)&quot; &quot;(doc encrypt)&quot; &quot;(ns user)&quot; &quot;(doc msprandom.crypto/encrypt)&quot; &quot;\&quot;hello\&quot;&quot; &quot;\\A&quot; &quot;3/2&quot; &quot;3234732984723987498237498237498372984732894783927489327498723984723894723894987&quot; &quot;[2 3 4 5 6]&quot; &quot;[2 3 4 5]&quot; &quot;'(1 2 3 4)&quot; &quot;{\&quot;hello\&quot; 1 \&quot;olga\&quot; 2}&quot; &quot;({\&quot;hello\&quot; 1 \&quot;olga\&quot; 2} \&quot;olga\&quot;)&quot; &quot;#{ 1 2 3 4 5 6 7}&quot; &quot;#{ 1 2 3 4 5 6 7 7 7 7 7 7 7 }&quot; &quot;(+ 1 2)&quot; &quot;(1 2 3 4)&quot; &quot;(list 1 2 3 4 5)&quot; &quot;(println \&quot;hello\&quot;)&quot; &quot;(- 4 2)&quot; &quot;(+ 1 2 3 4 5 6)&quot; &quot;(println (+ 1 2) (+ 3 4))&quot; &quot;(defn square\n  [x]\n  (* x x))&quot; &quot;(square 2)&quot; &quot;(defn квадрат\n  [x]\n  (* x x))&quot; &quot;(квадрат 8)&quot; &quot;(defn квадрат\n  [x y]\n  [(* x x) (* y y)])&quot; &quot;(defn квадрат\n  ([x] (* x x))\n  ([x y]\n   [(* x x) (* y y)]))&quot; &quot;(квадрат 2 3)&quot; &quot;(квадрат 2)&quot; &quot;(defn сложитель\n  [x &amp; rest]\n  (+ 0 x rest))&quot; &quot;(defn сложитель\n  [x &amp; rest]\n  (+ 0 x))&quot; &quot;(сложитель 1)&quot; &quot;2&quot; &quot;(defn раствор \n  [натрий хлор калий]\n  (str натрий (.toUpperCase калий) хлор))&quot; &quot;(раствор \&quot;2нат\&quot; \&quot;3хлор\&quot; \&quot;1калий\&quot;)&quot; &quot;(defn раствор \n  [компоненты]\n &quot; &quot;(defn раствор \n  [компоненты]\n  (let [натрий (компоненты натрий)\n        хлор (компоненты хлор)\n        калий (компоненты калий)]\n    (str натрий (.toUpperCase калий) хлор)))&quot; &quot;1&quot; &quot;(defn раствор \n  [компоненты]\n  (let [натрий (компоненты :натрий)\n        хлор (компоненты :хлор)\n        калий (компоненты :калий)]\n    (str натрий (.toUpperCase калий) хлор)))&quot; &quot;(def фн def)&quot; &quot;(def фн 'def)&quot; &quot;(фн плюс [x y] (+ x y) )&quot; &quot;'(фн плюс [x y] (+ x y) )&quot; &quot;(eval '(фн плюс [x y] (+ x y)))&quot; &quot;(defn раствор \n  [компоненты]\n  (let [ {:keys [натрий хлор калий]} компоненты]\n    (str натрий (.toUpperCase калий) хлор)))&quot; &quot;(раствор {:хлор \&quot;3хлор\&quot; :натрий \&quot;2натрий\&quot; :калий \&quot;1калий\&quot;})&quot; &quot;(if true\n  (println \&quot;ok\&quot;)\n  (println \&quot;error\&quot;))&quot; &quot;(if (= 1 1)\n  (println \&quot;ok\&quot;)\n  (println \&quot;error\&quot;))&quot; &quot;(if (= 1 2)\n  (println \&quot;ok\&quot;)\n  (println \&quot;error\&quot;))&quot; &quot;(if (= 1 2)\n  (println \&quot;ok\&quot;)\n  (do\n    (println \&quot;false\&quot;)\n    [1 2]))&quot; &quot;(range 1 10)&quot; &quot;(inc 1)&quot; &quot;(map inc v )&quot; &quot;(count v)&quot; &quot;(iterate (println 1) 3)&quot; &quot;(iterate println 3)&quot; &quot;(doc iterate)&quot; &quot;(take 10 (iterate println 1))&quot; &quot;(def v [1 2 3 4 5 6 7 8 9])&quot; &quot;(conj v 1)&quot; &quot;(conj v \\a)&quot; &quot;v&quot; &quot;(defn new-random-vault\n    \&quot;Create new file as random vault with 512 bits of true random data.\n    Vault is encrypted with password and ptotected with HMAC.\n    This function works only in console mode.\&quot;\n  [^String vname\n   ^String passw]\n  (let [rand-data (msprandom.kbd/kbdrand 64)\n        lhalf (Arrays/copyOfRange rand-data 0 31)\n        rhalf (Arrays/copyOfRange rand-data 32 64)]\n    (println (seq rand-data))\n    (println (seq lhalf))\n    (println (seq rhalf))))&quot; &quot;(msprandom.core/new-random-vault \&quot;ad\&quot; \&quot;df\&quot;)&quot; &quot;(def n (System/nanoTime))&quot; &quot;(def s (.getBytes (str \&quot;hello\&quot;)))&quot; &quot;s&quot; &quot;(c/gost-hash (byte-array (concat s (.getBytes (str n)))))&quot; &quot;(concat s (.getBytes (str n)))&quot; &quot;\n(concat s (.getBytes (str n)))&quot; &quot;(byte-array (concat s (.getBytes (str n))))&quot; &quot;(seq (byte-array (concat s (.getBytes (str n)))))&quot; &quot;(alength (.getBytes (str n)))&quot; &quot;(str (.getBytes (str n)))&quot; &quot;(String. (.getBytes (str n)))&quot; &quot;(def seed (load-vault \&quot;vault.edn\&quot; \&quot;Secret12\&quot;))&quot; &quot;seed&quot; &quot;(vec seed)&quot; &quot;(defn rand-bytes\n  \&quot;Generate secure random bytes using given seed. Seed must be array of true random bytes &gt;= 32 bytes\n  Returns: array filled with random bytes or nil.\&quot;\n  [^bytes rand-seed\n   ^long n]\n  (if rand-seed\n    (let [half-selector (rand-int 2)\n          nanosec (System/nanoTime)\n          ekey (c/gost-hash (byte-array (concat rand-seed (.getBytes (str nanosec)))))\n          iv (Arrays/copyOfRange ^bytes (.getBytes (str (System/nanoTime))) 0 8)          ;generate iv\n          e (c/gost-engine ekey iv true)                    ;init gost engine for encryption\n          buf (byte-array n)\n          enc-data (c/encrypt e buf)                        ;encrypt empty array\n          ]\n      enc-data)\n    (throw (Exception. \&quot;Got empty seed.\&quot;))))&quot; &quot;(c/bytes-to-hex (rand-bytes seed 10))&quot; &quot;(c/bytes-to-hex (rand-bytes seed 100))&quot; &quot;(c/bytes-to-hex (rand-bytes seed 50))&quot; &quot;(c/bytes-to-hex (rand-bytes nil 50))&quot; &quot;(c/bytes-to-hex (gen-rand seed 50))&quot; &quot;(c/bytes-to-hex (gen-rand seed 1))&quot; &quot;(c/bytes-to-hex (gen-rand seed 0))&quot; &quot;(c/bytes-to-hex (gen-rand seed 20))&quot;], :remote [&quot;(def c (chan))&quot; &quot;(random-generator c)&quot; &quot;(def v (async/&lt;!! c))&quot; &quot;0&quot; &quot;(+ 2 2)&quot;]}}</component>
</project>